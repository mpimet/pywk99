"""
Create composites of wave-filtered data following Lott et al. 2014.

Currently, composites are built by splitting the timeseries into a user-defined
amount of temporal windows, before the maximum of a wave index is selected as a
wave event each window. Afterwards, it is checked whether the selected wave
events have a certain temporal distance to each other to ensure their
independence, and for events which are too close to each other, one event is
dropped. The composite is then generated by averaging across the selected wave
events.

TODO:
Creating the composite via crossing a threshold instead of as maxima in windows
"""

from typing import Optional, Tuple
import xarray as xr
import numpy as np
import datetime

def get_wave_composite(
    data: xr.Dataset,
    detect_var: str,
    composite_days: int = None,
    detect_window_days: int = None,
    delta_wave_events_days: int = None,
    detailed_output: bool=False,
    detect_level: Optional[float] = None
    ) -> Tuple[xr.Dataset, Optional[xr.DataArray], Optional[xr.DataArray]]:
    """
    Get a composite of a filtered variable.

    Input:
    ------
    data: xr.Dataset
        The input dataset containting all the variables which should be analyzed
        in the composite analysis.
    detect_var: str
        The name of the variable which should be used to create the composite.
        It must be part of 'data'.
    composite_days: int
        The length of the composite in days. The data of the composite will have
        'composite_days'+1 data records due to day zero.
        If 'composite_days' is uneven, the algorithm automatically uses the
        first even number lower than 'composite_days'.
    detect_window_days: int
        The length of the windows, in each of which one wave event will be
        selected, in days.
    delta_wave_events_days: int
        Minimum amount of days that have to be between two wave events to ensure
        their temporal independence, otherwise one of those two events will be
        excluded from creating the composite.
    detailed_output: bool
        If 'True', also 'wave_idx' and 'wave_events' are returned as output.
        Default: False.
    detect_level: Optional[tuple(str, float)]:
        The level at which 'detect_var' should be evaluated in case it is
        3-dimensional.

    Output:
    -------
    composite: xr.Dataset
        Dataset containting all input variables composited with respect to the
        `detect_var`.
    wave_idx: xr.DataArray; optional, only returned if `detailed_output=True`
        Timeseries of the wave index which is used to select the wave events
        from which the composite is built.
    wave_events: xr.DataArray; Optional, only returned if `detailed_output=True`
        Array containing the times of wave events from which the composite is
        built.
    """

    composite_days_half = np.timedelta64(int(composite_days/2), 'D')
    detect_window_days = np.timedelta64(detect_window_days, 'D')
    delta_wave_events_days = np.timedelta64(delta_wave_events_days, 'D')

    for var in data.data_vars:
        _check_dimnames(data[var])
    detect_data = _select_detect_data(data, detect_var, detect_level)
    wave_idx = _build_wave_index(detect_data)
    wave_events = _select_wave_events(
        wave_idx, composite_days_half, detect_window_days, 
        delta_wave_events_days
        )
    composite = _create_wave_composite(data, wave_events, wave_idx,
                                       composite_days_half)
    if detailed_output:
        return composite, wave_idx, wave_events
    else:
        return composite


def _select_detect_data(
        data: xr.Dataset,
        detect_var: str,
        detect_level: float,
        ) -> xr.Dataset:
    '''
    Selects the data of the variable, which should be used to detect the wave 
    events, from the input xr.Dataset as an xr.DataArray
    '''
    if detect_var not in data:
        error_str = "The 'detect_var' you provided is not a variable in " + \
            "'data'. Please provide a valid 'detect_var'!"
        raise ValueError(error_str)
    detect_data = data[detect_var]
    if "height" in detect_data.dims:
        detect_data = detect_data.sel(height=detect_level, method='nearest')
    elif "plev" in detect_data.dims:
        detect_data = detect_data.sel(plev=detect_level, method='nearest')
    return detect_data


def _build_wave_index(
        data: xr.DataArray,
        index_method: str="lat_mean",
        ) -> xr.DataArray:
    """
    Builds the wave index based on which the wave events will be selected.

    Input:
    ------
    data: xr.DataArray
        Data from which the wave index should be calculated
    index_method: str
        Method which should be used to create the wave index. Default: lat_mean
    """
    if index_method == "lat_mean":
        return data.mean('lat')
    else:
        error_str = "Invalid 'index_method', please provide a valid one. " + \
        "Currently implemented valid 'index_method':: 'lat_mean'."
        raise ValueError(error_str)


def _select_wave_events(
        wave_idx: xr.DataArray,
        composite_days_half: np.timedelta64,
        detect_window_days: np.timedelta64,
        delta_wave_events_days: np.timedelta64,
        ) -> xr.DataArray:
    '''
    Create a list containing the dates of the maxima in each detection window
    '''
    wave_idx_maxima = _select_wave_idx_maximum(wave_idx, composite_days_half,
                                               detect_window_days)
    wave_events = [
        xr.DataArray(
            data=[wave_idx['time'].data[0]],
            coords={"time": [wave_idx['time'].data[0]]},
            dims="time",
            )
        ]
    for peak in wave_idx_maxima:
        wave_events.append(
            wave_idx.time.where(wave_idx.max('lon') == peak.values, drop=True)
        )
    wave_events = xr.concat(wave_events, dim='time')
    wave_events = _remove_too_close_events(wave_events,
                                           delta_wave_events_days)
    return wave_events


def _remove_too_close_events(
        wave_events: xr.DataArray,
        delta_wave_events_days: np.timedelta64,
        ) -> xr.DataArray:
    '''
    Removes wave events, which are too close together
    '''
    return wave_events.where(
        wave_events.diff('time') > delta_wave_events_days, drop=True
        )


def _select_wave_idx_maximum(
        wave_idx: xr.DataArray,
        composite_days_half: np.timedelta64,
        detect_window_days: np.timedelta64,
        ) -> xr.DataArray:
    '''
    Splits the timeseries into windows and selects the maximum of the wave index
    per window.
    '''
    analysis_time_range = slice(wave_idx['time'][0] + composite_days_half,
                                wave_idx['time'][-1] - composite_days_half
                                )
    wave_idx_max = wave_idx.sel(time=analysis_time_range).max('lon').resample(
        time=_timedelta64_to_timedelta(detect_window_days)).max('time')
    return wave_idx_max


def _create_wave_composite(
    data: xr.Dataset,
    wave_events: xr.DataArray,
    wave_idx: xr.DataArray,
    composite_days_half: np.timedelta64,
    ) -> xr.Dataset:
    '''
    Creates the wave composite.
    '''
    composite_dict = {}

    for event in wave_events:
        event_data = data.sel(
            time=slice(event-composite_days_half, event+composite_days_half)
            )
        event_data_freq = _get_data_frequency(event_data)
        event_data['time'] = np.arange(
            -composite_days_half, composite_days_half+event_data_freq,
            event_data_freq
            )
        composite_dict[str(event.values)] = _center_at_longitude(
            event_data, wave_idx, event
            )
    
    wave_composite = xr.concat(
        [composite_dict[str(event.values)] for event in wave_events],
        dim='events').mean('events')
    return wave_composite


def _center_at_longitude(
        data: xr.Dataset,
        wave_idx: xr.DataArray,
        event: np.datetime64
        ) -> xr.Dataset:
    '''
    Calculates the shift in lognitude needed to center the maximum value of
    'wave_idx' at 180Â°E and applies this shift to the longitude coordinates.
    '''
    max_lon = wave_idx.sel(time=event).idxmax('lon')
    shift = -max_lon.values
    data['lon'] = shift_longitude(data['lon'], shift)
    data = data.sortby(data['lon'])
    return data
    

def shift_longitude(lon: xr.DataArray, shift: float) -> xr.DataArray:
    lon_shifted = (lon + shift + 180) % 360 - 180
    return lon_shifted


def _check_dimnames(array: xr.DataArray) -> None:
    if not 'time' and 'lat' and 'lon' in array.dims:
        error_str = "Please ensure that the input DataArrays have the " + \
            "following dimension names: 'time', 'lat', 'lon'!"
        raise NameError(error_str)
    if len(array.dims) == 4 and ('height' not in array.dims != 'plev' not in
                                 array.dims):
        error_str = "Please ensure that the input DataArrays has a valid " + \
            "dimension name for the vertical dimension. Valid names are: " + \
                "'plev', 'height'!"
        raise NameError(error_str)


def _timedelta64_to_timedelta(td: np.timedelta64) -> datetime.timedelta:
    return datetime.timedelta(seconds=td / np.timedelta64(1, 's'))


def _get_data_frequency(data: xr.DataArray) -> np.timedelta64:
    return data['time'].diff('time')[0].values